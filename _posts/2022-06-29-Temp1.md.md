---
layout: single
title: "Temp1"
categories: coding
tags: [python, basic programming]
---

# Numeric Data
### Type : Integer(int), Float(float), Complex

#### int 의 기본 크기는 28 byte 이다
- 24 byte 는 class int 를 형성하는 데 쓰인다
- 4 byte 는 실제로 입력되는 값의 저장에 쓰이며, 부족할 경우 4 byte 씩 크기가 증가한다

int 의 경우, 1 bit 는 $0(+)$  $or$  $1(-)$ 을 나타내고, 나머지 bit 는 $2^0, 2^1, 2^2, ...$ 의 포함 여부를 나타내어 정수를 표현한다


```python
import sys

print("{0} : {1}".format("bytes of 2"        .ljust(18), sys.getsizeof(2)))
print("{0} : {1}".format("bytes of 2**30 - 1".ljust(18), sys.getsizeof(2**30 - 1)))
print("{0} : {1}".format("bytes of 2**30"    .ljust(18), sys.getsizeof(2**30)))
print("{0} : {1}".format("bytes of 2**60 - 1".ljust(18), sys.getsizeof(2**60 - 1)))
print("{0} : {1}".format("bytes of 2**60"    .ljust(18), sys.getsizeof(2**60)))
```

    bytes of 2         : 28
    bytes of 2**30 - 1 : 28
    bytes of 2**30     : 32
    bytes of 2**60 - 1 : 32
    bytes of 2**60     : 36
    

#### float 의 크기는 24 byte 이다
- 16 byte 는 class float 를 형성하는 데 쓰인다
- 8 byte 는 실제로 입력되는 값의 저장에 쓰이며, 정확하게 표현하지 못하더라도 크기를 증가시키지 않는다

float 의 경우, 1 bit 는 $0(+)$  $or$  $1(-)$ 를 나타내고, 11 bit 는 지수부, 52 bit 는 가수부로 사용하여 부동 소수점 표현으로 나타낸다 <br> <br>

#### 부동 소수점 표현
float 로 입력을 받은 것의 정수부와 소수부를 2진수로 나타낸다
- 정수부는 int 와 동일한 논리이고, 소수부는 $2^{-1}, 2^{-2}, ...$ 를 사용하여 근사화시킨다 <br>

그렇게 만들어진 2진수의 소수점을 이동시켜서 $1.xxx..._{(2)}$ $\times$ $2^E$ 형태로 만들어준다
- 위의 과정을 '정규화'라고 하며, 이 때 $E$ 는 지수부이고, $xxx...$ 는 가수부이다
- 지수부는 부호를 나타내기 위해 실제 지수에 $2^{10}$ 를 더해서 저장한다. <br>
  그러면 $-$ 의 경우 맨 앞의 bit 는 $0$ 이 되고, $+$ 의 경우 맨 앞의 bit 는 $1$ 이 된다
- 가수부는 52 bit 이므로, 앞에서부터 52개의 2진수를 받으며, 부족할 경우 뒤에 $0$을 채운다 <br>


- $111.1$ 의 경우, 부호부는 $0(+)$ 이고, 정수부와 소수부를 2진수로 나타내면 $1101111.0001100110011001100...$ $_{(2)}$ 이다 <br>
  소수점을 이동시키면 $1.1011110001100110011001100..._{(2)}$  $\times$  $2^6$ 으로 나타내진다 <br>
  그러므로 지수부는 $6+2^{10}$ $_{(10)}$ $=$ $10000110$ $_{(2)}$ 이고, 가수부는 $1011110001100110011001100...$ (52자리) 이다 <br> <br>


```python
print("{0} : {1}".format("expression of (22)**50"  .ljust(24), (22)**50))
print("{0} : {1}".format("expression of (2.2)**50" .ljust(24), (2.2)**50))
print("{0} : {1}".format("expression of (0.22)**50".ljust(24), (0.22)**50))
# e+17 : (front number) * 10**17
# e-33 : (front number) * 10**(-33)
```

    expression of (22)**50   : 13217035032142513618039644258500715884299760500166608934135475994624
    expression of (2.2)**50  : 1.3217035032142566e+17
    expression of (0.22)**50 : 1.3217035032142518e-33
    

float 는 위와 같이 정확한 값을 저장하지 못하기에 연산이 부정확성이 생길 수 있다 <br>

동등성만 해결하려면 math.isclose(a, b, rel_tol=1e-09, abs_tol=0.0) 를 사용할 수 있으며 <br>
게산의 정확성까지 해결하려면 decimal 모듈의 Decimal 인스턴스를 사용하여 연산해야 한다 <br>
- **Warning** : Decimal 은 고정 소수점을 사용하여 정확하게 표현하는 것이다
  - 지수부 없이 정수부와 소수부를 그대로 저장하기에, 크기를 많이 차지한다
  - 이미 근사화된 값을 정확하게 변환시킬 수는 없으므로, float 가 아니라 string 을 받아야 한다


```python
import math
from decimal import Decimal

print("{0} : {1}".format("0.1 + 0.2 == 0.3".ljust(50), 0.1 + 0.2 == 0.3))
print("{0} : {1}".format("math.isclose(0.1 + 0.2, 0.3)".ljust(50), math.isclose(0.1 + 0.2, 0.3)))
print("{0} : {1}".format("Decimal('0.1') + Decimal('0.2') == Decimal('0.3')".ljust(50), Decimal('0.1') + Decimal('0.2') == Decimal('0.3'))); print()

print("{0} : {1}".format("0.1 + 0.2".ljust(50), 0.1 + 0.2))
print("{0} : {1}".format("float(Decimal('0.1') + Decimal('0.2'))".ljust(50), float(Decimal('0.1') + Decimal('0.2'))))

```

    0.1 + 0.2 == 0.3                                   : False
    math.isclose(0.1 + 0.2, 0.3)                       : True
    Decimal('0.1') + Decimal('0.2') == Decimal('0.3')  : True
    
    0.1 + 0.2                                          : 0.30000000000000004
    float(Decimal('0.1') + Decimal('0.2'))             : 0.3
    

#### complex 의 크기는 32 byte 이다
- A = complex(a, b) 라고 정의하면 A.real = a 이고 A.imag = b 가 되는데, 이 A.real 과 A.imag 는 float 이다
- 따라서 16 byte 로 형성할 class complex 에 class float 의 내용이 포함된다
- 그리고 8 byte 는 A.real, 나머지 8 byte 는 A.imag 의 값의 저장에 쓰인다


```python
A = complex(0.3, 0.4)
print("|{0} + {1}i| = {2}".format(A.real, A.imag, abs(A)))
```

    |0.3 + 0.4i| = 0.5
    
